{
  "$defs": {
    "model": {
      "description": "The Hugging Face model to be used",
      "instillAcceptFormats": [
        "string"
      ],
      "instillUpstreamTypes": [
        "value",
        "reference",
        "template"
      ],
      "title": "Model",
      "type": "string"
    },
    "options": {
      "properties": {
        "use_cache": {
          "description": "There is a cache layer on the inference API to speedup requests we have already seen. Most models can use those results as is as models are deterministic (meaning the results will be the same anyway). However if you use a non deterministic model, you can set this parameter to prevent the caching mechanism from being used resulting in a real new query.",
          "instillAcceptFormats": [
            "boolean"
          ],
          "instillShortDescription": "Enable the cache of inference API",
          "instillUIOrder": 1,
          "instillUpstreamTypes": [
            "value",
            "reference"
          ],
          "title": "Use Cache",
          "type": "boolean"
        },
        "wait_for_model": {
          "description": "If the model is not ready, wait for it instead of receiving 503. It limits the number of requests required to get your inference done. It is advised to only set this flag to true after receiving a 503 error as it will limit hanging in your application to known places.",
          "instillAcceptFormats": [
            "boolean"
          ],
          "instillShortDescription": "Wait for model ready",
          "instillUIOrder": 0,
          "instillUpstreamTypes": [
            "value",
            "reference"
          ],
          "title": "Wait For Model",
          "type": "boolean"
        }
      },
      "required": [],
      "title": "Options",
      "type": "object"
    },
    "string_input": {
      "description": "String input",
      "instillAcceptFormats": [
        "string"
      ],
      "instillUIOrder": 0,
      "instillUpstreamTypes": [
        "value",
        "reference",
        "template"
      ],
      "title": "String Input",
      "type": "string"
    }
  },
  "TASK_AUDIO_CLASSIFICATION": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "audio": {
          "description": "The audio file",
          "instillAcceptFormats": [
            "audio/*"
          ],
          "instillUIOrder": 1,
          "instillUpstreamTypes": [
            "reference"
          ],
          "title": "Audio",
          "type": "string"
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        }
      },
      "required": [
        "audio"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "classes": {
          "instillUIOrder": 0,
          "items": {
            "properties": {
              "label": {
                "description": "The label for the class (model specific)",
                "instillFormat": "string",
                "instillUIOrder": 0,
                "title": "Label",
                "type": "string"
              },
              "score": {
                "description": "A float that represents how likely it is that the audio file belongs to this class.",
                "instillFormat": "number",
                "instillUIOrder": 1,
                "title": "Score",
                "type": "number"
              }
            },
            "required": [
              "label",
              "score"
            ],
            "type": "object"
          },
          "title": "Classes",
          "type": "array"
        }
      },
      "required": [
        "classes"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_CONVERSATIONAL": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "inputs": {
          "instillUIOrder": 1,
          "properties": {
            "generated_responses": {
              "description": "A list of strings corresponding to the earlier replies from the model.",
              "instillAcceptFormats": [
                "array:string"
              ],
              "instillUIOrder": 0,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "items": {
                "instillUIMultiline": true,
                "type": "string"
              },
              "title": "Generated Responses",
              "type": "array"
            },
            "past_user_inputs": {
              "description": "A list of strings corresponding to the earlier replies from the user. Should be of the same length of generated_responses.",
              "instillAcceptFormats": [
                "array:string"
              ],
              "instillShortDescription": "A list of strings corresponding to the earlier replies from the user.",
              "instillUIOrder": 1,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "items": {
                "instillUIMultiline": true,
                "type": "string"
              },
              "title": "Past User Inputs",
              "type": "array"
            },
            "text": {
              "description": "The last input from the user in the conversation.",
              "instillAcceptFormats": [
                "string"
              ],
              "instillUIMultiline": true,
              "instillUIOrder": 2,
              "instillUpstreamTypes": [
                "value",
                "reference",
                "template"
              ],
              "title": "Text",
              "type": "string"
            }
          },
          "required": [
            "text"
          ],
          "title": "Inputs",
          "type": "object"
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        },
        "options": {
          "$ref": "#/$defs/options",
          "instillUIOrder": 3
        },
        "parameters": {
          "instillUIOrder": 2,
          "properties": {
            "max_length": {
              "description": "Integer to define the maximum length in tokens of the output summary.",
              "instillAcceptFormats": [
                "integer"
              ],
              "instillUIOrder": 0,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Max Length",
              "type": "integer"
            },
            "max_time": {
              "description": "The amount of time in seconds that the query should take maximum. Network can cause some overhead so it will be a soft limit.",
              "instillAcceptFormats": [
                "number",
                "integer"
              ],
              "instillShortDescription": "The amount of time in seconds that the query should take maximum.",
              "instillUIOrder": 1,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "maximum": 120.0,
              "minimum": 0.0,
              "title": "Max Time",
              "type": "number"
            },
            "min_length": {
              "description": "Integer to define the minimum length in tokens of the output summary.",
              "instillAcceptFormats": [
                "integer"
              ],
              "instillUIOrder": 2,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Min Length",
              "type": "integer"
            },
            "repetition_penalty": {
              "description": "The more a token is used within generation the more it is penalized to not be picked in successive generation passes.",
              "instillAcceptFormats": [
                "number",
                "integer"
              ],
              "instillUIOrder": 3,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "maximum": 100.0,
              "minimum": 0.0,
              "title": "Repetition Penalty",
              "type": "number"
            },
            "temperature": {
              "default": 1.0,
              "description": "The temperature of the sampling operation. 1 means regular sampling, 0 means always take the highest score, 100.0 is getting closer to uniform probability.",
              "instillAcceptFormats": [
                "number",
                "integer"
              ],
              "instillShortDescription": "The temperature of the sampling operation.",
              "instillUIOrder": 4,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "maximum": 100.0,
              "minimum": 0.0,
              "title": "Temperature",
              "type": "number"
            },
            "top_k": {
              "description": "Integer to define the top tokens considered within the sample operation to create new text.",
              "instillAcceptFormats": [
                "integer"
              ],
              "instillUIOrder": 5,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Top K",
              "type": "integer"
            },
            "top_p": {
              "description": "Float to define the tokens that are within the sample operation of text generation. Add tokens in the sample for more probable to least probable until the sum of the probabilities is greater than top_p.",
              "instillAcceptFormats": [
                "number",
                "integer"
              ],
              "instillShortDescription": "Float to define the tokens that are within the sample operation of text generation.",
              "instillUIOrder": 6,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Top P",
              "type": "number"
            }
          },
          "required": [],
          "title": "Parameters",
          "type": "object"
        }
      },
      "required": [
        "inputs"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "conversation": {
          "description": "A facility dictionnary to send back for the next input (with the new user input addition).",
          "instillUIOrder": 0,
          "properties": {
            "generated_responses": {
              "description": "List of strings. The last outputs from the model in the conversation, after the model has run.",
              "instillUIOrder": 0,
              "items": {
                "instillFormat": "string",
                "instillUIMultiline": true,
                "type": "string"
              },
              "title": "Generated Responses",
              "type": "array"
            },
            "past_user_inputs": {
              "description": "List of strings. The last inputs from the user in the conversation, after the model has run.",
              "instillUIOrder": 1,
              "items": {
                "instillFormat": "string",
                "instillUIMultiline": true,
                "type": "string"
              },
              "title": "Past User Inputs",
              "type": "array"
            }
          },
          "required": [
            "generated_responses",
            "past_user_inputs"
          ],
          "title": "Conversation",
          "type": "object"
        },
        "generated_text": {
          "description": "The answer of the bot",
          "instillFormat": "string",
          "instillUIMultiline": true,
          "instillUIOrder": 1,
          "title": "Generated Text",
          "type": "string"
        }
      },
      "required": [
        "generated_text"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_FILL_MASK": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "inputs": {
          "$ref": "#/$defs/string_input",
          "description": "a string to be filled from, must contain the [MASK] token (check model card for exact name of the mask)",
          "instillUIOrder": 1
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        },
        "options": {
          "$ref": "#/$defs/options",
          "instillUIOrder": 2
        }
      },
      "required": [
        "inputs"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "results": {
          "instillUIOrder": 0,
          "items": {
            "properties": {
              "score": {
                "description": "The probability for this token.",
                "instillFormat": "number",
                "instillUIOrder": 0,
                "title": "Score",
                "type": "number"
              },
              "sequence": {
                "description": "The actual sequence of tokens that ran against the model (may contain special tokens)",
                "instillFormat": "string",
                "instillUIMultiline": true,
                "instillUIOrder": 1,
                "title": "Sequence",
                "type": "string"
              },
              "token": {
                "description": "The id of the token",
                "instillFormat": "integer",
                "instillUIOrder": 2,
                "title": "Token",
                "type": "integer"
              },
              "token_str": {
                "description": "The string representation of the token",
                "instillFormat": "string",
                "instillUIOrder": 3,
                "title": "Token Str",
                "type": "string"
              }
            },
            "required": [],
            "type": "object"
          },
          "title": "Results",
          "type": "array"
        }
      },
      "required": [
        "results"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_IMAGE_CLASSIFICATION": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "image": {
          "description": "The image file",
          "instillAcceptFormats": [
            "image/*"
          ],
          "instillUIOrder": 1,
          "instillUpstreamTypes": [
            "reference"
          ],
          "title": "Image",
          "type": "string"
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        }
      },
      "required": [
        "image"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "classes": {
          "instillUIOrder": 0,
          "items": {
            "properties": {
              "label": {
                "description": "The label for the class (model specific)",
                "instillFormat": "string",
                "instillUIOrder": 0,
                "title": "Label",
                "type": "string"
              },
              "score": {
                "description": "A float that represents how likely it is that the image file belongs to this class.",
                "instillFormat": "number",
                "instillUIOrder": 0,
                "title": "Score",
                "type": "number"
              }
            },
            "required": [
              "label",
              "score"
            ],
            "type": "object"
          },
          "title": "Classes",
          "type": "array"
        }
      },
      "required": [
        "classes"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_IMAGE_SEGMENTATION": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "image": {
          "description": "The image file",
          "instillAcceptFormats": [
            "image/*"
          ],
          "instillUIOrder": 1,
          "instillUpstreamTypes": [
            "reference"
          ],
          "title": "Image",
          "type": "string"
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        }
      },
      "required": [
        "image"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "segments": {
          "instillUIOrder": 0,
          "items": {
            "properties": {
              "label": {
                "description": "The label for the class (model specific) of a segment.",
                "instillFormat": "string",
                "instillUIOrder": 0,
                "title": "Label",
                "type": "string"
              },
              "mask": {
                "description": "A str (base64 str of a single channel black-and-white img) representing the mask of a segment.",
                "instillFormat": "image/png",
                "instillUIOrder": 1,
                "title": "Mask",
                "type": "string"
              },
              "score": {
                "description": "A float that represents how likely it is that the segment belongs to the given class.",
                "instillFormat": "number",
                "instillUIOrder": 2,
                "title": "Score",
                "type": "number"
              }
            },
            "required": [
              "label",
              "mask",
              "score"
            ],
            "type": "object"
          },
          "title": "Segments",
          "type": "array"
        }
      },
      "required": [
        "segments"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_IMAGE_TO_TEXT": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "image": {
          "description": "The image file",
          "instillAcceptFormats": [
            "image/*"
          ],
          "instillUIOrder": 0,
          "instillUpstreamTypes": [
            "reference"
          ],
          "title": "Image",
          "type": "string"
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        }
      },
      "required": [
        "image"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "text": {
          "instillFormat": "string",
          "instillUIMultiline": true,
          "instillUIOrder": 0,
          "title": "Text",
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_OBJECT_DETECTION": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "image": {
          "description": "The image file",
          "instillAcceptFormats": [
            "image/*"
          ],
          "instillUIOrder": 1,
          "instillUpstreamTypes": [
            "reference"
          ],
          "title": "Image",
          "type": "string"
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        }
      },
      "required": [
        "image"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "objects": {
          "instillUIOrder": 0,
          "items": {
            "properties": {
              "box": {
                "description": "A dict (with keys [xmin,ymin,xmax,ymax]) representing the bounding box of a detected object.",
                "instillUIOrder": 0,
                "properties": {
                  "xmax": {
                    "instillFormat": "number",
                    "instillUIOrder": 0,
                    "title": "X Max",
                    "type": "number"
                  },
                  "xmin": {
                    "instillFormat": "number",
                    "instillUIOrder": 1,
                    "title": "X Min",
                    "type": "number"
                  },
                  "ymax": {
                    "instillFormat": "number",
                    "instillUIOrder": 2,
                    "title": "Y Max",
                    "type": "number"
                  },
                  "ymin": {
                    "instillFormat": "number",
                    "instillUIOrder": 3,
                    "title": "Y min",
                    "type": "number"
                  }
                },
                "required": [
                  "xmax",
                  "xmin",
                  "ymax",
                  "ymin"
                ],
                "title": "Box",
                "type": "object"
              },
              "label": {
                "description": "The label for the class (model specific) of a detected object.",
                "instillFormat": "string",
                "instillUIOrder": 1,
                "title": "Label",
                "type": "string"
              },
              "score": {
                "description": "A float that represents how likely it is that the detected object belongs to the given class.",
                "instillFormat": "number",
                "instillUIOrder": 2,
                "title": "Score",
                "type": "number"
              }
            },
            "required": [
              "box",
              "label",
              "score"
            ],
            "type": "object"
          },
          "title": "Objects",
          "type": "array"
        }
      },
      "required": [
        "objects"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_QUESTION_ANSWERING": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "inputs": {
          "instillUIOrder": 1,
          "properties": {
            "context": {
              "description": "The context for answering the question.",
              "instillAcceptFormats": [
                "string"
              ],
              "instillUIMultiline": true,
              "instillUIOrder": 0,
              "instillUpstreamTypes": [
                "value",
                "reference",
                "template"
              ],
              "title": "Context",
              "type": "string"
            },
            "question": {
              "description": "The question",
              "instillAcceptFormats": [
                "string"
              ],
              "instillUIMultiline": true,
              "instillUIOrder": 1,
              "instillUpstreamTypes": [
                "value",
                "reference",
                "template"
              ],
              "title": "Question",
              "type": "string"
            }
          },
          "required": [
            "question",
            "context"
          ],
          "title": "Inputs",
          "type": "object"
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        },
        "options": {
          "$ref": "#/$defs/options",
          "instillUIOrder": 2
        }
      },
      "required": [
        "inputs"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "answer": {
          "description": "A string that\u2019s the answer within the text.",
          "instillFormat": "string",
          "instillUIMultiline": true,
          "instillUIOrder": 0,
          "title": "Answer",
          "type": "string"
        },
        "score": {
          "description": "A float that represents how likely that the answer is correct",
          "instillFormat": "number",
          "instillUIOrder": 2,
          "title": "Score",
          "type": "number"
        },
        "start": {
          "description": "The index (string wise) of the start of the answer within context.",
          "instillFormat": "integer",
          "instillUIOrder": 3,
          "title": "Start",
          "type": "integer"
        },
        "stop": {
          "description": "The index (string wise) of the stop of the answer within context.",
          "instillFormat": "integer",
          "instillUIOrder": 1,
          "title": "Stop",
          "type": "integer"
        }
      },
      "required": [
        "answer"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_SENTENCE_SIMILARITY": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "inputs": {
          "instillUIOrder": 1,
          "properties": {
            "sentences": {
              "description": "A list of strings which will be compared against the source_sentence.",
              "instillAcceptFormats": [
                "array:string"
              ],
              "instillUIOrder": 0,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "items": {
                "instillUIMultiline": true,
                "type": "string"
              },
              "title": "Sentences",
              "type": "array"
            },
            "source_sentence": {
              "description": "The string that you wish to compare the other strings with. This can be a phrase, sentence, or longer passage, depending on the model being used.",
              "instillAcceptFormats": [
                "string"
              ],
              "instillShortDescription": "The string that you wish to compare the other strings with.",
              "instillUIMultiline": true,
              "instillUIOrder": 1,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Source Sentence",
              "type": "string"
            }
          },
          "required": [
            "source_sentence",
            "sentences"
          ],
          "title": "Inputs",
          "type": "object"
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        },
        "options": {
          "$ref": "#/$defs/options",
          "instillUIOrder": 2
        }
      },
      "required": [
        "inputs"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "scores": {
          "description": "The associated similarity score for each of the given strings",
          "instillUIOrder": 0,
          "items": {
            "instillFormat": "number",
            "type": "number"
          },
          "title": "Scores",
          "type": "array"
        }
      },
      "required": [
        "scores"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_SPEECH_RECOGNITION": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "audio": {
          "description": "The audio file",
          "instillAcceptFormats": [
            "audio/*"
          ],
          "instillUIOrder": 1,
          "instillUpstreamTypes": [
            "reference"
          ],
          "title": "Audio",
          "type": "string"
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        }
      },
      "required": [
        "audio"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "text": {
          "description": "The string that was recognized within the audio file.",
          "instillFormat": "string",
          "instillUIMultiline": true,
          "instillUIOrder": 0,
          "title": "Text",
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_SUMMARIZATION": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "inputs": {
          "$ref": "#/$defs/string_input",
          "instillUIOrder": 1
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        },
        "options": {
          "$ref": "#/$defs/options",
          "instillUIOrder": 3
        },
        "parameters": {
          "instillUIOrder": 2,
          "properties": {
            "max_length": {
              "description": "Integer to define the maximum length in tokens of the output summary.",
              "instillAcceptFormats": [
                "integer"
              ],
              "instillUIOrder": 0,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Max Length",
              "type": "integer"
            },
            "max_time": {
              "instillAcceptFormats": [
                "number",
                "integer"
              ],
              "instillUIOrder": 1,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "maximum": 120.0,
              "minimum": 0.0,
              "title": "Max Time",
              "type": "number"
            },
            "min_length": {
              "description": "Integer to define the minimum length in tokens of the output summary.",
              "instillAcceptFormats": [
                "integer"
              ],
              "instillUIOrder": 2,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Min Length",
              "type": "integer"
            },
            "repetition_penalty": {
              "description": "The more a token is used within generation the more it is penalized to not be picked in successive generation passes.",
              "instillAcceptFormats": [
                "number",
                "integer"
              ],
              "instillUIOrder": 3,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "maximum": 100.0,
              "minimum": 0.0,
              "title": "Repetition Penalty",
              "type": "number"
            },
            "temperature": {
              "default": 1.0,
              "description": "The temperature of the sampling operation. 1 means regular sampling, 0 means always take the highest score, 100.0 is getting closer to uniform probability.",
              "instillAcceptFormats": [
                "number",
                "integer"
              ],
              "instillShortDescription": "The temperature of the sampling operation.",
              "instillUIOrder": 4,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "maximum": 100.0,
              "minimum": 0.0,
              "title": "Temperature",
              "type": "number"
            },
            "top_k": {
              "description": "Integer to define the top tokens considered within the sample operation to create new text.",
              "instillAcceptFormats": [
                "integer"
              ],
              "instillUIOrder": 5,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Top K",
              "type": "integer"
            },
            "top_p": {
              "description": "Float to define the tokens that are within the sample operation of text generation. Add tokens in the sample for more probable to least probable until the sum of the probabilities is greater than top_p.",
              "instillAcceptFormats": [
                "number",
                "integer"
              ],
              "instillShortDescription": "Float to define the tokens that are within the sample operation of text generation.",
              "instillUIOrder": 6,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Top P",
              "type": "number"
            }
          },
          "required": [],
          "title": "Parameters",
          "type": "object"
        }
      },
      "required": [
        "inputs"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "summary_text": {
          "description": "The string after summarization",
          "instillFormat": "string",
          "instillUIMultiline": true,
          "instillUIOrder": 0,
          "title": "Summary Text",
          "type": "string"
        }
      },
      "required": [
        "summary_text"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_TABLE_QUESTION_ANSWERING": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "inputs": {
          "instillUIOrder": 1,
          "properties": {
            "query": {
              "description": "The query in plain text that you want to ask the table",
              "instillAcceptFormats": [
                "string"
              ],
              "instillUIMultiline": true,
              "instillUIOrder": 0,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Query",
              "type": "string"
            },
            "table": {
              "description": "A table of data represented as a dict of list where entries are headers and the lists are all the values, all lists must have the same size.",
              "instillAcceptFormats": [
                "*"
              ],
              "instillUIOrder": 1,
              "instillUpstreamTypes": [
                "reference",
                "value"
              ],
              "required": [],
              "title": "Table",
              "type": "object"
            }
          },
          "required": [
            "query",
            "table"
          ],
          "title": "Inputs",
          "type": "object"
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        },
        "options": {
          "$ref": "#/$defs/options",
          "instillUIOrder": 2
        }
      },
      "required": [
        "inputs"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "aggregator": {
          "description": "The aggregator used to get the answer",
          "instillFormat": "string",
          "instillUIOrder": 0,
          "title": "Aggregator",
          "type": "string"
        },
        "answer": {
          "description": "The plaintext answer",
          "instillFormat": "string",
          "instillUIMultiline": true,
          "instillUIOrder": 1,
          "title": "Answer",
          "type": "string"
        },
        "cells": {
          "description": "a list of coordinates of the cells contents",
          "instillUIOrder": 2,
          "items": {
            "instillFormat": "string",
            "instillUIMultiline": true,
            "type": "string"
          },
          "title": "Cells",
          "type": "array"
        },
        "coordinates": {
          "description": "a list of coordinates of the cells referenced in the answer",
          "instillUIOrder": 3,
          "items": {
            "items": {
              "instillFormat": "integer",
              "type": "integer"
            },
            "type": "array"
          },
          "title": "Coordinates",
          "type": "array"
        }
      },
      "required": [
        "answer"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_TEXT_CLASSIFICATION": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "inputs": {
          "$ref": "#/$defs/string_input",
          "instillUIOrder": 1
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        },
        "options": {
          "$ref": "#/$defs/options",
          "instillUIOrder": 2
        }
      },
      "required": [
        "inputs"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "results": {
          "instillUIOrder": 0,
          "items": {
            "properties": {
              "label": {
                "description": "The label for the class (model specific)",
                "instillFormat": "string",
                "instillUIOrder": 0,
                "title": "Label",
                "type": "string"
              },
              "score": {
                "description": "A floats that represents how likely is that the text belongs the this class.",
                "instillFormat": "number",
                "instillUIOrder": 1,
                "title": "Score",
                "type": "number"
              }
            },
            "required": [
              "label",
              "score"
            ],
            "type": "object"
          },
          "title": "Results",
          "type": "array"
        }
      },
      "required": [
        "results"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_TEXT_GENERATION": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "inputs": {
          "$ref": "#/$defs/string_input",
          "instillUIOrder": 1
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        },
        "options": {
          "$ref": "#/$defs/options",
          "instillUIOrder": 3
        },
        "parameters": {
          "instillUIOrder": 2,
          "properties": {
            "do_sample": {
              "description": "Whether or not to use sampling, use greedy decoding otherwise.",
              "instillAcceptFormats": [
                "boolean"
              ],
              "instillUIOrder": 0,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Do Sample",
              "type": "boolean"
            },
            "max_new_tokens": {
              "description": "The amount of new tokens to be generated, this does not include the input length it is a estimate of the size of generated text you want. Each new tokens slows down the request, so look for balance between response times and length of text generated.",
              "instillAcceptFormats": [
                "integer"
              ],
              "instillShortDescription": "The amount of new tokens to be generated.",
              "instillUIOrder": 1,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Max New Tokens",
              "type": "integer"
            },
            "max_time": {
              "description": "The amount of time in seconds that the query should take maximum. Network can cause some overhead so it will be a soft limit. Use that in combination with max_new_tokens for best results.",
              "instillAcceptFormats": [
                "number",
                "integer"
              ],
              "instillShortDescription": "The amount of time in seconds that the query should take maximum.",
              "instillUIOrder": 2,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Max Time",
              "type": "number"
            },
            "num_return_sequences": {
              "description": "The number of proposition you want to be returned.",
              "instillAcceptFormats": [
                "integer"
              ],
              "instillUIOrder": 3,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Num Return Sequences",
              "type": "integer"
            },
            "repetition_penalty": {
              "description": "The more a token is used within generation the more it is penalized to not be picked in successive generation passes.",
              "instillAcceptFormats": [
                "number",
                "integer"
              ],
              "instillUIOrder": 4,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Repetition Penalty",
              "type": "number"
            },
            "return_full_text": {
              "description": "If set to False, the return results will not contain the original query making it easier for prompting.",
              "instillAcceptFormats": [
                "boolean"
              ],
              "instillUIOrder": 5,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Return Full Text",
              "type": "boolean"
            },
            "temperature": {
              "description": "The temperature of the sampling operation. 1 means regular sampling, 0 means always take the highest score, 100.0 is getting closer to uniform probability.",
              "instillAcceptFormats": [
                "number",
                "integer"
              ],
              "instillShortDescription": "The temperature of the sampling operation.",
              "instillUIOrder": 6,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Temperature",
              "type": "number"
            },
            "top_k": {
              "description": "Integer to define the top tokens considered within the sample operation to create new text.",
              "instillAcceptFormats": [
                "integer"
              ],
              "instillUIOrder": 7,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Top K",
              "type": "integer"
            },
            "top_p": {
              "description": "Float to define the tokens that are within the sample operation of text generation. Add tokens in the sample for more probable to least probable until the sum of the probabilities is greater than top_p.",
              "instillAcceptFormats": [
                "number",
                "integer"
              ],
              "instillShortDescription": "Float to define the tokens that are within the sample operation of text generation.",
              "instillUIOrder": 8,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Top P",
              "type": "number"
            }
          },
          "required": [],
          "title": "Parameters",
          "type": "object"
        }
      },
      "required": [
        "inputs"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "generated_text": {
          "description": "The continuated string",
          "instillFormat": "string",
          "instillUIMultiline": true,
          "instillUIOrder": 1,
          "title": "Generated Text",
          "type": "string"
        }
      },
      "required": [
        "generated_text"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_TEXT_TO_IMAGE": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "inputs": {
          "$ref": "#/$defs/string_input",
          "instillUIOrder": 1
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        },
        "options": {
          "$ref": "#/$defs/options",
          "instillUIOrder": 3
        },
        "parameters": {
          "instillUIOrder": 2,
          "properties": {
            "guidance_scale": {
              "description": "Guidance scale",
              "instillAcceptFormats": [
                "number",
                "integer"
              ],
              "instillUIOrder": 0,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Guidance Scale",
              "type": "number"
            },
            "height": {
              "description": "Image Height",
              "instillAcceptFormats": [
                "integer"
              ],
              "instillUIOrder": 1,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Height",
              "type": "integer"
            },
            "negative_prompt": {
              "description": "Negative prompt for generating the image",
              "instillAcceptFormats": [
                "string"
              ],
              "instillUIMultiline": true,
              "instillUIOrder": 2,
              "instillUpstreamTypes": [
                "value",
                "reference",
                "template"
              ],
              "title": "Negative Prompt",
              "type": "string"
            },
            "num_inference_steps": {
              "description": "Number of inference steps",
              "instillAcceptFormats": [
                "integer"
              ],
              "instillUIOrder": 3,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Num Inference Steps",
              "type": "integer"
            },
            "width": {
              "description": "Image width",
              "instillAcceptFormats": [
                "integer"
              ],
              "instillUIOrder": 4,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Width",
              "type": "integer"
            }
          },
          "required": [],
          "title": "Parameters",
          "type": "object"
        }
      },
      "required": [
        "inputs"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "image": {
          "instillFormat": "image/jpeg",
          "instillUIOrder": 0,
          "title": "Image",
          "type": "string"
        }
      },
      "required": [
        "image"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_TOKEN_CLASSIFICATION": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "inputs": {
          "$ref": "#/$defs/string_input",
          "instillUIOrder": 1
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        },
        "options": {
          "$ref": "#/$defs/options",
          "instillUIOrder": 3
        },
        "parameters": {
          "instillUIOrder": 2,
          "properties": {
            "aggregation_strategy": {
              "description": "There are several aggregation strategies:\nnone: Every token gets classified without further aggregation.\nsimple: Entities are grouped according to the default schema (B-, I- tags get merged when the tag is similar).\nfirst: Same as the simple strategy except words cannot end up with different tags. Words will use the tag of the first token when there is ambiguity.\naverage: Same as the simple strategy except words cannot end up with different tags. Scores are averaged across tokens and then the maximum label is applied.\nmax: Same as the simple strategy except words cannot end up with different tags. Word entity will be the token with the maximum score.",
              "instillAcceptFormats": [
                "string"
              ],
              "instillShortDescription": "There are several aggregation strategies: none, simple, first, average, and max.",
              "instillUIOrder": 0,
              "instillUpstreamTypes": [
                "value",
                "reference",
                "template"
              ],
              "title": "Aggregation Strategy",
              "type": "string"
            }
          },
          "required": [],
          "title": "Parameters",
          "type": "object"
        }
      },
      "required": [
        "inputs"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "results": {
          "instillUIOrder": 0,
          "items": {
            "properties": {
              "end": {
                "description": "The offset stringwise where the answer is located. Useful to disambiguate if word occurs multiple times.",
                "instillFormat": "integer",
                "instillUIOrder": 0,
                "title": "End",
                "type": "integer"
              },
              "entity_group": {
                "description": "The type for the entity being recognized (model specific).",
                "instillFormat": "string",
                "instillUIOrder": 1,
                "title": "Entity Group",
                "type": "string"
              },
              "score": {
                "description": "How likely the entity was recognized.",
                "instillFormat": "number",
                "instillUIOrder": 2,
                "title": "Score",
                "type": "number"
              },
              "start": {
                "description": "The offset stringwise where the answer is located. Useful to disambiguate if word occurs multiple times.",
                "instillFormat": "integer",
                "instillUIOrder": 3,
                "title": "Start",
                "type": "integer"
              },
              "word": {
                "description": "The string that was captured",
                "instillFormat": "string",
                "instillUIMultiline": true,
                "instillUIOrder": 4,
                "title": "Word",
                "type": "string"
              }
            },
            "required": [],
            "type": "object"
          },
          "title": "Results",
          "type": "array"
        }
      },
      "required": [
        "results"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_TRANSLATION": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "inputs": {
          "$ref": "#/$defs/string_input",
          "instillUIOrder": 1
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        },
        "options": {
          "$ref": "#/$defs/options",
          "instillUIOrder": 2
        }
      },
      "required": [
        "inputs"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "translation_text": {
          "description": "The string after translation",
          "instillFormat": "string",
          "instillUIMultiline": true,
          "instillUIOrder": 0,
          "title": "Translation Text",
          "type": "string"
        }
      },
      "required": [
        "translation_text"
      ],
      "title": "Output",
      "type": "object"
    }
  },
  "TASK_ZERO_SHOT_CLASSIFICATION": {
    "input": {
      "instillUIOrder": 0,
      "properties": {
        "inputs": {
          "$ref": "#/$defs/string_input",
          "instillUIOrder": 1
        },
        "model": {
          "$ref": "#/$defs/model",
          "instillUIOrder": 0
        },
        "options": {
          "$ref": "#/$defs/options",
          "instillUIOrder": 3
        },
        "parameters": {
          "instillUIOrder": 2,
          "properties": {
            "candidate_labels": {
              "description": "a list of strings that are potential classes for inputs. (max 10 candidate_labels, for more, simply run multiple requests, results are going to be misleading if using too many candidate_labels anyway. If you want to keep the exact same, you can simply run multi_label=True and do the scaling on your end. )",
              "instillShortDescription": "a list of strings that are potential classes for inputs.",
              "instillUIOrder": 0,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "items": {
                "title": "candidate_label",
                "type": "string"
              },
              "title": "Candidate Labels",
              "type": "array"
            },
            "multi_label": {
              "description": "Boolean that is set to True if classes can overlap",
              "instillAcceptFormats": [
                "boolean"
              ],
              "instillUIOrder": 1,
              "instillUpstreamTypes": [
                "value",
                "reference"
              ],
              "title": "Multi Label",
              "type": "boolean"
            }
          },
          "required": [
            "candidate_labels"
          ],
          "title": "Parameters",
          "type": "object"
        }
      },
      "required": [
        "inputs",
        "parameters"
      ],
      "title": "Input",
      "type": "object"
    },
    "output": {
      "instillUIOrder": 0,
      "properties": {
        "labels": {
          "description": "The list of strings for labels that you sent (in order)",
          "instillUIOrder": 1,
          "items": {
            "instillFormat": "string",
            "type": "string"
          },
          "title": "Labels",
          "type": "array"
        },
        "scores": {
          "description": "a list of floats that correspond the the probability of label, in the same order as labels.",
          "instillUIOrder": 0,
          "items": {
            "instillFormat": "number",
            "type": "number"
          },
          "title": "Scores",
          "type": "array"
        },
        "sequence": {
          "description": "The string sent as an input",
          "instillFormat": "string",
          "instillUIMultiline": true,
          "instillUIOrder": 1,
          "title": "Sequence",
          "type": "string"
        }
      },
      "required": [
        "labels",
        "scores"
      ],
      "title": "Output",
      "type": "object"
    }
  }
}
